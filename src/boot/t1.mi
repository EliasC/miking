/* 
   Miking is licensed under the MIT license. 
   Copyright (C) David Broman. See file LICENSE.txt
*/


// Test
//(1 + 2 * 5) / 3 - (9 % 2)

//5 != 6

//(if 5 == 3 then 3 + 1 else if true then 7 + 1 else 0) + 2

//(x => y => x + 1 + y)(2,4)

//(x => y => x + 1 + y)(1,3)

//def foo(x) = 8 + x
//foo(2) + 1 - foo(1)

//def foo(x,y) = x * y * y
//def boo(n) = n + n
//dprint(foo(boo(2),3) + 1)
//dprint(7)

//def foo() = 4
//dprint(foo())


//def foo(x) = {
//    dprint(x)
//    1
//}
//dprint(foo(2))


//def foo(x) {
//    dprint(x)p
//    1
//}
//dprint(foo(3))


def fact(n) {
    dprint(n)
    if n <= 1 then 1 else n*fact(n-1)
}

dprint(fact(5))
//dprint(20)

//def x = [4,7,9,2,2]
//dprint(x)

//dprint('K')

//def fact(n:Int) -> Int {
//    dprint(n)
//    if n <= 1 then 1 else n*fact(n-1)
//}



// Apply function [f] to each element of [lst]
// f: The function that is applied to each list element
// lst: The list
//def map(f:a->b, lst:List(a)) -> List(b) = match lst { 
//    x::ls -> f(x)::map(f,ls)
//    [] -> []//
//}



//def count(n) = match n {
//    Node(t1,t2) -> count(t1) + count(t2)
//    Leaf(v) -> v
//}


//[1,3,2,3,4]

//def a = 7::[3,2]
//def b = 1::2::3::[]
//append(a,b)





